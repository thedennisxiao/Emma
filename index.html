<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Question Under the Stars</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }

        #scene-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Background image layer for crisp rendering */
        #sky-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            z-index: 0;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            image-rendering: auto;
        }


        /* Star canvas - above background */
        #star-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Content area - centered */
        #content-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            max-width: 800px;
            height: 60%;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Interactive buttons container */
        #button-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            z-index: 20;
        }

        #button-container.visible {
            opacity: 1;
        }

        /* Ethereal button styling */
        .response-button {
            padding: 12px 32px;
            font-family: 'Georgia', serif;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2),
                        inset 0 1px 1px rgba(255, 255, 255, 0.1);
        }

        /* Subtle glow effect */
        .response-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .response-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
            color: rgba(255, 255, 255, 1);
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.2),
                        inset 0 1px 1px rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .response-button:hover::before {
            width: 300px;
            height: 300px;
        }

        .response-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 255, 255, 0.15),
                        inset 0 1px 1px rgba(255, 255, 255, 0.1);
        }

        /* Specific button variants */
        #yes-button:hover {
            border-color: rgba(173, 216, 230, 0.7);
            box-shadow: 0 6px 25px rgba(173, 216, 230, 0.3),
                        inset 0 1px 1px rgba(255, 255, 255, 0.2);
        }

        #no-button:hover {
            border-color: rgba(255, 192, 203, 0.5);
            box-shadow: 0 6px 20px rgba(255, 192, 203, 0.2),
                        inset 0 1px 1px rgba(255, 255, 255, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #content-area {
                width: 80%;
                height: 70%;
            }

            #button-container {
                gap: 30px;
                bottom: 12%;
            }

            .response-button {
                padding: 10px 28px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            #content-area {
                width: 90%;
                height: 75%;
            }

            #button-container {
                gap: 20px;
                bottom: 10%;
            }

            .response-button {
                padding: 8px 24px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <!-- Background sky image -->
        <img id="sky-background" src="Emma_night_sky.png?v=2" alt="Night sky background">
        
        <!-- Star Field Canvas -->
        <canvas id="star-canvas"></canvas>

        <!-- Content Area -->
        <div id="content-area">
            <!-- Interactive buttons appear after text formation -->
            <div id="button-container">
                <button id="yes-button" class="response-button">Yes</button>
                <button id="no-button" class="response-button">No</button>
            </div>
        </div>
    </div>

    <script>
        // ===== PHASE 5: CONSTELLATION TRANSFORMATION =====

        // Canvas setup
        const canvas = document.getElementById('star-canvas');
        const ctx = canvas.getContext('2d');

        // DOM elements
        const buttonContainer = document.getElementById('button-container');
        const yesButton = document.getElementById('yes-button');
        const noButton = document.getElementById('no-button');

        // Animation configuration
        const STAR_COUNT = 400; // Increased to fill more sky space with better distribution
        const ANIMATION_DURATION = 4.0; // seconds - longer for ultra-smooth fade
        const BUTTON_DELAY = 1.0; // seconds after text formation
        const CONSTELLATION_DURATION = 2.0; // seconds for constellation formation
        const stars = [];
        let animationStartTime = null;
        let isAnimating = false;
        let isFormingConstellations = false;

        // Star class for managing individual stars
        class Star {
            constructor(x, y, radius, color, twinkleSpeed, twinkleOffset) {
                // Current position
                this.x = x;
                this.y = y;

                // Initial random position (for animation start)
                this.startX = x;
                this.startY = y;

                // Target position (for text formation)
                this.targetX = x;
                this.targetY = y;

                this.radius = radius;
                this.color = color;
                this.twinkleSpeed = twinkleSpeed;
                this.twinkleOffset = twinkleOffset;
                this.isTextStar = false; // Track if this star is part of text
                this.fadeInProgress = 1.0; // 0 = invisible, 1 = fully visible
                this.fadeDelay = 0; // Delay before this star starts fading in (for stagger effect)
                this.textStarVariation = {
                    sizeMultiplier: 1.0, // Variation in size (0.7 to 1.3)
                    brightnessMultiplier: 1.0, // Variation in brightness (0.6 to 1.0)
                    shapeType: 0 // Shape variation: 0 = circle, 1 = cross, 2 = small dot
                };
            }

            // Set target position for text formation
            setTarget(targetX, targetY) {
                this.targetX = targetX;
                this.targetY = targetY;
                // IMPORTANT: Don't change current position - stars stay at startX/startY until animation begins
                // The animation will handle moving from start to target
            }

            // Update position based on animation progress
            updatePosition(progress) {
                // Ease-in-out cubic function
                const eased = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                this.x = this.startX + (this.targetX - this.startX) * eased;
                this.y = this.startY + (this.targetY - this.startY) * eased;
            }

            // Calculate opacity based on time for twinkle effect
            getOpacity(time) {
                if (this.isTextStar) {
                    // Text stars: fadeInProgress directly controls opacity (0 = invisible, 1 = fully visible)
                    // During fade-in, fadeInProgress smoothly goes from 0 to 1
                    // After fade-in complete, add subtle twinkle with brightness variation
                    if (this.fadeInProgress >= 0.999) {
                        // Fade-in complete, add subtle twinkle with brightness variation
                        const baseOpacity = 0.85 + 0.15 * Math.sin(time * this.twinkleSpeed + this.twinkleOffset);
                        return baseOpacity * this.textStarVariation.brightnessMultiplier;
                    } else {
                        // During fade-in: use fadeInProgress with brightness variation
                        return this.fadeInProgress * this.textStarVariation.brightnessMultiplier;
                    }
                } else {
                    // Background stars: Sine wave for smooth pulsing (0.7 to 1.0 opacity range - brighter)
                    return 0.7 + 0.3 * Math.sin(time * this.twinkleSpeed + this.twinkleOffset);
                }
            }
            
            // Get display radius (text stars are larger for visibility, with variation)
            getDisplayRadius() {
                if (this.isTextStar) {
                    // Apply size variation to text stars
                    return this.radius * 2.0 * this.textStarVariation.sizeMultiplier;
                }
                return this.radius;
            }

            draw(time) {
                const opacity = this.getOpacity(time);
                const displayRadius = this.getDisplayRadius();
                
                // Skip drawing if completely invisible (use threshold for smooth fade)
                if (opacity < 0.01) return;
                
                if (this.isTextStar) {
                    // Text stars: varied shapes, sizes, and brightness
                    ctx.shadowBlur = displayRadius * 3;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    // Draw different shapes based on variation
                    const shapeType = this.textStarVariation.shapeType;
                    ctx.globalAlpha = Math.max(0, Math.min(1, opacity)); // Clamp opacity
                    
                    if (shapeType < 0.7) {
                        // 70% are circles (standard)
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, displayRadius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgb(255, 255, 255)';
                        ctx.fill();
                    } else if (shapeType < 0.9) {
                        // 20% are cross/sparkle shapes
                        ctx.strokeStyle = 'rgb(255, 255, 255)';
                        ctx.lineWidth = Math.max(0.5, displayRadius * 0.2);
                        ctx.beginPath();
                        // Horizontal line
                        ctx.moveTo(this.x - displayRadius * 1.1, this.y);
                        ctx.lineTo(this.x + displayRadius * 1.1, this.y);
                        // Vertical line
                        ctx.moveTo(this.x, this.y - displayRadius * 1.1);
                        ctx.lineTo(this.x, this.y + displayRadius * 1.1);
                        ctx.stroke();
                        // Center dot
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, displayRadius * 0.5, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgb(255, 255, 255)';
                        ctx.fill();
                    } else {
                        // 10% are smaller dots
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, displayRadius * 0.7, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgb(255, 255, 255)';
                        ctx.fill();
                    }
                } else {
                    // Background stars: subtle glow
                    ctx.shadowBlur = this.radius * 2;
                    ctx.shadowColor = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, displayRadius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = Math.max(0, Math.min(1, opacity));
                    ctx.fill();
                }
                
                // Reset shadow and alpha
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        // Simple dot-matrix letter definitions (5x7 grid)
        // Each letter is an array of [x, y] coordinates
        const LETTERS = {
            'W': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,5],[2,4],[2,5],[2,6],[3,5],[4,0],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6]],
            'I': [[0,0],[1,0],[2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[0,6],[1,6],[2,6],[3,6],[4,6]],
            'L': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,6],[2,6],[3,6],[4,6]],
            'Y': [[0,0],[0,1],[0,2],[1,2],[2,3],[2,4],[2,5],[2,6],[3,2],[4,0],[4,1],[4,2]],
            'O': [[1,0],[2,0],[3,0],[0,1],[4,1],[0,2],[4,2],[0,3],[4,3],[0,4],[4,4],[0,5],[4,5],[1,6],[2,6],[3,6]],
            'U': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,6],[2,6],[3,6],[4,0],[4,1],[4,2],[4,3],[4,4],[4,5]],
            'B': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,0],[2,0],[3,0],[4,1],[4,2],[3,3],[2,3],[1,3],[4,4],[4,5],[3,6],[2,6],[1,6]],
            'E': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,0],[2,0],[3,0],[4,0],[1,3],[2,3],[3,3],[1,6],[2,6],[3,6],[4,6]],
            'M': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,1],[2,2],[3,1],[4,0],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6]],
            'P': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,0],[2,0],[3,0],[4,1],[4,2],[3,3],[2,3],[1,3]],
            'A': [[2,0],[1,1],[3,1],[0,2],[4,2],[0,3],[4,3],[1,3],[2,3],[3,3],[0,4],[4,4],[0,5],[4,5],[0,6],[4,6]],
            'R': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,0],[2,0],[3,0],[4,1],[4,2],[3,3],[2,3],[1,3],[2,4],[3,5],[4,6]],
            'T': [[0,0],[1,0],[2,0],[3,0],[4,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6]],
            'N': [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,1],[2,2],[2,3],[3,4],[4,0],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6]],
            '?': [[1,0],[2,0],[3,0],[0,1],[4,1],[4,2],[3,3],[2,4],[2,6]],
            ' ': []
        };

        // Constellation patterns (normalized 0-1 coordinates)
        // Orca Whale - left constellation
        const ORCA_PATTERN = [
            // Dorsal fin (distinctive feature)
            [0.45, 0.15], [0.48, 0.10], [0.51, 0.05], [0.54, 0.10], [0.57, 0.15],
            // Head and rostrum
            [0.20, 0.40], [0.25, 0.35], [0.30, 0.32], [0.35, 0.30],
            // Eye patch
            [0.32, 0.36],
            // Upper body
            [0.40, 0.30], [0.50, 0.25], [0.60, 0.28], [0.70, 0.32],
            // Lower body / belly
            [0.25, 0.45], [0.35, 0.48], [0.45, 0.50], [0.55, 0.48], [0.65, 0.45], [0.72, 0.42],
            // Tail section
            [0.75, 0.38], [0.80, 0.35], [0.83, 0.32],
            // Tail flukes (spread)
            [0.85, 0.25], [0.88, 0.20], [0.90, 0.28], [0.92, 0.35], [0.90, 0.42], [0.88, 0.48],
            // Pectoral fin
            [0.40, 0.52], [0.38, 0.58], [0.36, 0.63], [0.35, 0.68]
        ];

        // Stag - right constellation
        const STAG_PATTERN = [
            // Antlers (most distinctive feature) - left antler
            [0.35, 0.05], [0.33, 0.12], [0.30, 0.18], [0.28, 0.10], [0.25, 0.15],
            // Right antler
            [0.50, 0.05], [0.52, 0.12], [0.55, 0.18], [0.57, 0.10], [0.60, 0.15],
            // Head
            [0.42, 0.22], [0.40, 0.28], [0.43, 0.32], [0.47, 0.32], [0.50, 0.28],
            // Ears
            [0.38, 0.20], [0.52, 0.20],
            // Neck
            [0.45, 0.36], [0.44, 0.42], [0.46, 0.48],
            // Back line
            [0.48, 0.52], [0.52, 0.54], [0.56, 0.55], [0.60, 0.54],
            // Chest/front body
            [0.42, 0.50], [0.40, 0.56], [0.42, 0.62],
            // Belly line
            [0.48, 0.58], [0.52, 0.60], [0.56, 0.60],
            // Rear
            [0.62, 0.52], [0.64, 0.58], [0.64, 0.64],
            // Front legs
            [0.44, 0.68], [0.44, 0.75], [0.44, 0.82],
            [0.48, 0.66], [0.48, 0.73], [0.48, 0.80],
            // Back legs
            [0.58, 0.66], [0.58, 0.73], [0.58, 0.80],
            [0.62, 0.68], [0.62, 0.75], [0.62, 0.82],
            // Tail
            [0.66, 0.50], [0.68, 0.48], [0.70, 0.46]
        ];

        // Initialize canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Generate text positions from letter definitions
        function generateTextPositions(text, centerX, centerY, dotSize) {
            const positions = [];
            const lines = text.split('\n');
            const lineHeight = 9 * dotSize;
            const totalHeight = lines.length * lineHeight;
            let startY = centerY - totalHeight / 2;

            lines.forEach((line, lineIndex) => {
                line = line.toUpperCase();
                const lineWidth = line.split('').reduce((width, char) => {
                    return width + (char === ' ' ? 4 : 6);
                }, -1) * dotSize;

                let startX = centerX - lineWidth / 2;
                let currentX = startX;

                for (let char of line) {
                    const letterDots = LETTERS[char] || [];
                    letterDots.forEach(([dx, dy]) => {
                        positions.push({
                            x: currentX + dx * dotSize,
                            y: startY + lineIndex * lineHeight + dy * dotSize
                        });
                    });
                    currentX += (char === ' ' ? 4 : 6) * dotSize;
                }
            });

            return positions;
        }

        // Generate stars with random positions
        function generateStars() {
            stars.length = 0;

            const width = canvas.width;
            const height = canvas.height;

            // Create stars with variation, avoiding tree areas but filling more sky space
            // Use smaller margins to fill more of the visible sky
            const skyMarginX = width * 0.15; // 15% margin on each side (smaller to fill more space)
            const skyMarginY = height * 0.20; // 20% margin on bottom (smaller to fill more space)
            const skyStartX = skyMarginX;
            const skyEndX = width - skyMarginX;
            const skyWidth = skyEndX - skyStartX;
            const skyStartY = 0; // Start from top
            const skyEndY = height - skyMarginY; // Avoid bottom tree area
            const skyHeight = skyEndY - skyStartY;
            
            for (let i = 0; i < STAR_COUNT; i++) {
                // More random distribution - add some variation to avoid square clustering
                // Use a weighted random distribution that favors center but allows spread
                const centerWeight = 0.3; // 30% chance to be near center, 70% random
                let x, y;
                
                if (Math.random() < centerWeight) {
                    // Cluster some stars near center
                    const centerX = width / 2;
                    const centerY = height / 3; // Upper third of sky
                    const spreadX = skyWidth * 0.4;
                    const spreadY = skyHeight * 0.4;
                    x = centerX + (Math.random() - 0.5) * spreadX;
                    y = centerY + (Math.random() - 0.5) * spreadY;
                    // Clamp to sky area
                    x = Math.max(skyStartX, Math.min(skyEndX, x));
                    y = Math.max(skyStartY, Math.min(skyEndY, y));
                } else {
                    // Random distribution across sky area
                    x = skyStartX + Math.random() * skyWidth;
                    y = skyStartY + Math.random() * skyHeight;
                }
                
                const radius = 0.8 + Math.random() * 1.2; // Smaller stars to match background image

                const colorChoice = Math.random();
                let color;
                if (colorChoice < 0.8) {
                    // Brighter white stars
                    color = `rgb(255, 255, 255)`;
                } else {
                    // Brighter blue stars
                    color = `rgb(200, 220, 255)`;
                }

                const twinkleSpeed = 0.3 + Math.random() * 0.5;
                const twinkleOffset = Math.random() * Math.PI * 2;

                stars.push(new Star(x, y, radius, color, twinkleSpeed, twinkleOffset));
            }
            
            // Don't set text targets here - wait until animation starts to avoid frame snap
        }

        // Set target positions for text formation
        function setTextTargets() {
            // Constrain to center area to avoid trees on sides - wider margins for full text
            const safeMarginX = canvas.width * 0.20; // 20% margin on each side (wider for text)
            const safeMarginY = canvas.height * 0.12; // 12% margin top/bottom
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 - canvas.height * 0.08; // Slightly higher to avoid bottom trees
            const dotSize = Math.min(canvas.width, canvas.height) * 0.009; // Smaller to ensure full text fits

            const text = "Will you\nbe my partner?";
            const positions = generateTextPositions(text, centerX, centerY, dotSize);
            
            // Use all positions - don't filter (text should fit within safe area with adjusted margins)
            const safePositions = positions;

            // Assign target positions for stars - they'll animate from random positions to text
            console.log(`Positioning ${safePositions.length} stars for text formation out of ${stars.length} total stars`);
            stars.forEach((star, i) => {
                if (i < safePositions.length) {
                    // Set target position (star will animate from current random position to here)
                    // IMPORTANT: Preserve the star's current random position as start position
                    star.startX = star.x; // Save current random position
                    star.startY = star.y; // Save current random position
                    star.setTarget(safePositions[i].x, safePositions[i].y);
                    star.isTextStar = true; // Mark as text star for enhanced visibility
                    star.fadeInProgress = 0.3; // Start slightly visible so we can see them moving
                    // Stagger the animation: each star starts slightly later for smooth effect
                    star.fadeDelay = (i / safePositions.length) * 0.2; // Spread over 20% of animation
                    
                    // Add variation to text stars: size, brightness, and shape
                    star.textStarVariation = {
                        sizeMultiplier: 0.7 + Math.random() * 0.6, // Size varies from 0.7x to 1.3x
                        brightnessMultiplier: 0.6 + Math.random() * 0.4, // Brightness varies from 0.6 to 1.0
                        shapeType: Math.random() // Random shape type
                    };
                } else {
                    // Extra stars stay in random positions within safe area
                    star.setTarget(
                        safeMarginX + Math.random() * (canvas.width - 2 * safeMarginX),
                        safeMarginY + Math.random() * (canvas.height - 2 * safeMarginY)
                    );
                    star.isTextStar = false; // Background star
                    star.fadeInProgress = 1; // Background stars are already visible
                }
            });
        }

        // Generate constellation positions
        function generateConstellationPositions() {
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;

            // Calculate constellation sizing (responsive)
            const constellationSize = Math.min(width, height) * 0.25;

            // Orca on the left (centered in left third of screen)
            const orcaCenterX = width * 0.3;
            const orcaPositions = ORCA_PATTERN.map(([x, y]) => ({
                x: orcaCenterX - constellationSize * 0.5 + x * constellationSize,
                y: centerY - constellationSize * 0.4 + y * constellationSize
            }));

            // Stag on the right (centered in right third of screen)
            const stagCenterX = width * 0.7;
            const stagPositions = STAG_PATTERN.map(([x, y]) => ({
                x: stagCenterX - constellationSize * 0.5 + x * constellationSize,
                y: centerY - constellationSize * 0.45 + y * constellationSize
            }));

            // Combine both constellations
            return [...orcaPositions, ...stagPositions];
        }

        // Set constellation targets for transformation
        function setConstellationTargets() {
            const positions = generateConstellationPositions();

            // Assign positions to stars
            stars.forEach((star, i) => {
                star.isTextStar = false; // Reset text star flag for constellations
                if (i < positions.length) {
                    star.setTarget(positions[i].x, positions[i].y);
                } else {
                    // Extra stars fade to random positions around constellations
                    const randSide = Math.random() < 0.5 ? 0.3 : 0.7;
                    star.setTarget(
                        canvas.width * randSide + (Math.random() - 0.5) * 200,
                        canvas.height / 2 + (Math.random() - 0.5) * 300
                    );
                }
            });
        }

        // Start text formation animation
        function startTextFormation() {
            if (!isAnimating) {
                // Text targets are already set in init() - just start the animation
                // This prevents frame snap since stars are already configured
                isAnimating = true;
                animationStartTime = Date.now() / 1000;
                console.log('Starting text formation animation...');
            }
        }

        // Start constellation formation
        function startConstellationFormation() {
            if (!isFormingConstellations) {
                // Update targets to constellation positions
                setConstellationTargets();

                // Reset animation timing
                isFormingConstellations = true;
                animationStartTime = Date.now() / 1000;
                console.log('Forming constellations: Orca (left) and Stag (right)...');
            }
        }

        // Animation loop
        let animationId;
        function animate() {
            const time = Date.now() * 0.001;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Animate stars moving from random positions to form text
            if (isAnimating) {
                const elapsed = time - animationStartTime;
                const progress = Math.min(elapsed / ANIMATION_DURATION, 1.0);

                // Animate text stars: move from random positions to text positions + fade in
                stars.forEach(star => {
                    if (star.isTextStar) {
                        // Calculate when this star should start animating (after its delay)
                        const animStartProgress = star.fadeDelay; // Delay as fraction of total duration
                        const animDuration = 1.0 - animStartProgress; // Remaining time after delay
                        
                        let starProgress = 0;
                        if (progress > animStartProgress && animDuration > 0) {
                            // Star has started animating - calculate its progress (0 to 1)
                            const elapsedSinceStart = progress - animStartProgress;
                            starProgress = Math.min(1, elapsedSinceStart / animDuration);
                        }
                        
                        // Smooth ease-in-out cubic for natural movement
                        const eased = starProgress < 0.5
                            ? 4 * starProgress * starProgress * starProgress
                            : 1 - Math.pow(-2 * starProgress + 2, 3) / 2;
                        
                        // Update position: animate from start position to target position
                        star.updatePosition(eased);
                        
                        // Fade in as they move (start at 0.3, fade to 1.0)
                        star.fadeInProgress = 0.3 + (eased * 0.7); // Smooth fade from 0.3 to 1.0
                    }
                });

                if (progress >= 1.0) {
                    isAnimating = false;
                    // Ensure all text stars are fully visible
                    stars.forEach(star => {
                        if (star.isTextStar) {
                            star.fadeInProgress = 1.0;
                        }
                    });
                    console.log('Text formation complete: "Will you be my partner"');

                    // Show buttons after a delay
                    setTimeout(() => {
                        showButtons();
                    }, BUTTON_DELAY * 1000);
                }
            }

            // Update star positions if forming constellations
            if (isFormingConstellations) {
                const elapsed = time - animationStartTime;
                const progress = Math.min(elapsed / CONSTELLATION_DURATION, 1.0);

                stars.forEach(star => star.updatePosition(progress));

                if (progress >= 1.0) {
                    isFormingConstellations = false;
                    console.log('Constellation formation complete! âœ¨');
                    console.log('Orca (left) represents strength and connection to the ocean.');
                    console.log('Stag (right) represents grace, nobility, and the forest.');
                }
            }

            // Draw all stars
            stars.forEach(star => star.draw(time));

            animationId = requestAnimationFrame(animate);
        }

        // Show interactive buttons
        function showButtons() {
            buttonContainer.classList.add('visible');
            console.log('Buttons revealed - awaiting response...');
        }

        // Handle button responses
        function handleResponse(response) {
            console.log(`Response: ${response}`);

            // Hide buttons
            buttonContainer.classList.remove('visible');

            // Trigger transformation sequence (same for both)
            setTimeout(() => {
                startTransformation();
            }, 500);
        }

        // Transformation sequence - dissolve text and form constellations
        function startTransformation() {
            console.log('Starting transformation sequence...');
            console.log('Text dissolving, constellations forming...');

            // Start constellation formation immediately
            startConstellationFormation();
        }

        // Button click handlers
        yesButton.addEventListener('click', () => handleResponse('Yes'));
        noButton.addEventListener('click', () => handleResponse('No'));

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            generateStars();
            // Hide buttons on resize to avoid positioning issues
            buttonContainer.classList.remove('visible');
        });

        // Initialize scene
        function init() {
            resizeCanvas();
            generateStars();
            
            // Set text targets immediately (but don't start animation yet)
            // This prevents the frame snap - stars are already configured as text stars
            setTextTargets();
            
            // Reset animation state so stars stay at random positions
            isAnimating = false;
            
            animate();

            // Start text formation after 1 second
            setTimeout(() => {
                startTextFormation();
            }, 1000);

            console.log('Emma Partner Proposal - Phase 5: Full Interactive Experience Ready');
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
